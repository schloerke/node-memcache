// Generated by CoffeeScript 1.3.1
var Client, boolKeys, crlf, crlfLen, do_store_action, endTag, endTagLen, errorRepliesMap, error_replies, fullEndTag, fullEndTagLen, incr_decr, isArray, stringKeys, tcp, trim, util, valueTag;

tcp = require('net');

util = require('util');

crlf = "\r\n";

crlfLen = crlf.length;

endTag = 'END\r\n';

endTagLen = endTag.length;

fullEndTag = '\r\nEND\r\n';

fullEndTagLen = fullEndTag.length;

valueTag = 'VALUE ';

error_replies = ['ERROR', 'NOT_FOUND', 'CLIENT_ERROR', 'SERVER_ERROR'];

errorRepliesMap = {
  ERROR: true,
  NOT_FOUND: true,
  CLIENT_ERROR: true,
  SERVER_ERROR: true
};

isArray = Array.isArray || function(obj) {
  return toString.call(obj) === '[object Array]';
};

trim = (function() {
  var trimLeft, trimRight;
  trimLeft = /^\s+/;
  trimRight = /\s+$/;
  return String.prototype.trim || function(text) {
    if (text != null) {
      return text.toString().replace(trimLeft, "").replace(trimRight, "");
    } else {
      return "";
    }
  };
})();

Client = exports.Client = function(port, host) {
  this.port = port || 11211;
  this.host = host || 'localhost';
  this.strBuffer = '';
  this.conn = null;
  this.sends = 0;
  this.replies = 0;
  this.callbacks = [];
  this.handles = [];
  this.tmpMultiGetValue = {};
  return this;
};

util.inherits(Client, process.EventEmitter);

Client.prototype.connect = function() {
  var self;
  if (this.conn) {
    return;
  }
  self = this;
  self.conn = new tcp.createConnection(self.port, self.host);
  self.conn.addListener("connect", function() {
    self.conn.setTimeout(0);
    self.conn.setNoDelay();
    self.emit("connect");
    self.dispatchHandles();
  });
  self.conn.addListener("data", function(data) {
    self.strBuffer += data;
    self.recieves += 1;
    self.handle_received_data();
  });
  self.conn.addListener("end", function() {
    var _ref;
    if ((_ref = self.conn) != null ? _ref.readyState : void 0) {
      self.conn.end();
      self.conn = null;
    }
  });
  self.conn.addListener("close", function() {
    self.conn = null;
    self.emit("close");
  });
  self.conn.addListener("timeout", function() {
    self.conn = null;
    self.emit("timeout");
  });
  return self.conn.addListener("error", function(ex) {
    self.conn = null;
    self.emit("error", ex);
  });
};

Client.prototype.addHandler = function(callback) {
  this.handles.push(callback);
  if (this.conn.readyState === 'open') {
    this.dispatchHandles();
  }
};

Client.prototype.dispatchHandles = function() {
  var handle, _i, _len, _ref;
  _ref = this.handles;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    handle = _ref[_i];
    if (typeof handle === "function") {
      handle();
    }
  }
  this.handles = [];
};

Client.prototype.query = function(query, type, callback) {
  this.callbacks.push({
    type: type,
    fn: callback
  });
  this.sends++;
  return this.conn.write(query + crlf);
};

Client.prototype.close = function() {
  var _ref;
  if (((_ref = this.conn) != null ? _ref.readyState : void 0) === "open") {
    this.conn.end();
    this.conn = null;
  }
};

Client.prototype.get = function(key, callback) {
  var keyIsArray;
  keyIsArray = false;
  if (isArray(key)) {
    keyIsArray = true;
    key = key.join(' ').replace(/\s{2,}/, " ");
    key = trim.call(key);
  }
  key = trim.call(key);
  if (keyIsArray || (key.indexOf(" ") !== -1)) {
    return this.query('get ' + key, 'get_multi', callback);
  } else {
    return this.query('get ' + key, 'get', callback);
  }
};

do_store_action = function(action) {
  return function(key, value, callback, lifetime, flags) {
    return this.store(action, key, value, callback, lifetime, flags);
  };
};

Client.prototype.set = do_store_action("set");

Client.prototype.add = do_store_action("add");

Client.prototype.replace = do_store_action("replace");

Client.prototype.append = do_store_action("append");

Client.prototype.prepend = do_store_action("prepend");

Client.prototype.store = function(cmd, key, value, callback, lifetime, flags) {
  var query, queryCmd, valueLen, valueStr;
  if ((typeof callback) !== 'function') {
    lifetime = callback;
    callback = null;
  }
  flags || (flags = 0);
  lifetime || (lifetime = 0);
  valueStr = value.toString();
  valueLen = Buffer.byteLength(valueStr);
  query = [cmd, key, flags, lifetime, valueLen];
  queryCmd = query.join(' ') + crlf + valueStr;
  return this.query(queryCmd, 'simple', callback);
};

Client.prototype.cas = function(key, value, unique, callback, lifetime, flags) {
  var query, queryCmd, valueLen;
  if ((typeof callback) !== 'function') {
    lifetime = callback;
    callback = null;
  }
  flags || (flags = 0);
  lifetime || (lifetime = 0);
  valueLen = value.length || 0;
  query = ['cas', key, flags, lifetime, valueLen, unique];
  queryCmd = query.join(' ') + crlf + value;
  return this.query(queryCmd, 'simple', callback);
};

Client.prototype.del = function(key, callback) {
  util.error("mc.del() is deprecated - use mc.delete() instead");
  return this["delete"](key, callback);
};

Client.prototype["delete"] = function(key, callback) {
  return this.query('delete ' + key, 'simple', callback);
};

Client.prototype.version = function(callback) {
  return this.query('version', 'version', callback);
};

incr_decr = function(type) {
  var cmd;
  cmd = type + ' ';
  return function(key, value, callback) {
    var queryCmd;
    if ((typeof value) === 'function') {
      callback = value;
      value = 1;
    }
    if (value == null) {
      value = 1;
    }
    if (callback == null) {
      callback = null;
    }
    queryCmd = cmd + key + ' ' + value;
    return this.query(queryCmd, 'simple', callback);
  };
};

Client.prototype.increment = incr_decr("incr");

Client.prototype.decrement = incr_decr("decr");

Client.prototype.stats = function(type, callback) {
  var queryCmd;
  if ((typeof type) === 'function') {
    callback = type;
    type = null;
  }
  queryCmd = "stats";
  if (type) {
    queryCmd += " " + type;
  }
  return this.query(queryCmd, 'stats', callback);
};

Client.prototype.handle_received_data = function() {
  var callback, nextResultAt, result, resultError, resultValue, waitOnCallback;
  while (this.strBuffer.length > 0) {
    result = this.determine_reply_handler(this.strBuffer);
    if (!result) {
      return;
    }
    resultValue = result[0], nextResultAt = result[1], resultError = result[2], waitOnCallback = result[3];
    this.strBuffer = this.strBuffer.substring(nextResultAt);
    if (waitOnCallback === true) {
      return;
    }
    callback = this.callbacks.shift();
    if (callback != null ? callback.fn : void 0) {
      this.replies++;
      callback.fn(resultError, resultValue);
    }
  }
};

Client.prototype.determine_reply_handler = function(strBuffer) {
  var crlfPos, cutPos, firstLine, type, _ref;
  crlfPos = strBuffer.indexOf(crlf);
  if (crlfPos === -1) {
    return null;
  }
  cutPos = strBuffer.indexOf(' ');
  if (cutPos < 0) {
    cutPos = crlfPos;
  }
  firstLine = strBuffer.substr(0, cutPos);
  if (errorRepliesMap[firstLine]) {
    return this.handle_error(strBuffer);
  }
  type = ((_ref = this.callbacks[0]) != null ? _ref.type : void 0) || null;
  if (type) {
    return this['handle_' + type](strBuffer);
  }
  return null;
};

Client.prototype.handle_get = function(strBuffer) {
  var bytesWritten, endPos, expectedByteLen, firstLineLen, noFirstLineDataStr, resultBuffer, resultValueStr, resultValueStrLength;
  if (strBuffer.indexOf(endTag) === 0) {
    return [null, endTagLen];
  }
  firstLineLen = strBuffer.indexOf(crlf) + crlfLen;
  expectedByteLen = strBuffer.substr(0, firstLineLen).split(' ')[3];
  expectedByteLen = parseInt(expectedByteLen, 10);
  noFirstLineDataStr = strBuffer.substr(firstLineLen);
  resultBuffer = new Buffer(expectedByteLen);
  bytesWritten = resultBuffer.write(noFirstLineDataStr, 0, expectedByteLen);
  if (bytesWritten < expectedByteLen) {
    return null;
  }
  resultValueStr = resultBuffer.toString();
  resultValueStrLength = resultValueStr.length;
  endPos = firstLineLen + resultValueStrLength;
  if (strBuffer.substr(endPos, fullEndTagLen) !== fullEndTag) {
    return null;
  }
  return [resultValueStr, endPos + fullEndTagLen, null];
};

Client.prototype.handle_get_multi = function(strBuffer) {
  var bytesWritten, collectedLength, endPos, expectedByteLen, firstLine, firstLineLen, firstLineParts, key, noFirstLineDataStr, resultBuffer, resultValueStr, resultValueStrLength, ret;
  ret = this.tmpMultiGetValue;
  collectedLength = 0;
  while (strBuffer.length > 0) {
    if (strBuffer.indexOf(endTag) === 0) {
      collectedLength += endTagLen;
      this.tmpMultiGetValue = {};
      return [ret, collectedLength, null, false];
    }
    firstLineLen = strBuffer.indexOf(crlf) + crlfLen;
    firstLine = strBuffer.substr(0, firstLineLen);
    firstLineParts = firstLine.split(' ');
    key = firstLineParts[1];
    expectedByteLen = firstLineParts[3];
    expectedByteLen = parseInt(expectedByteLen, 10);
    noFirstLineDataStr = strBuffer.substr(firstLineLen);
    resultBuffer = new Buffer(expectedByteLen);
    bytesWritten = resultBuffer.write(noFirstLineDataStr, 0, expectedByteLen);
    if (bytesWritten < expectedByteLen) {
      return [null, collectedLength, null, true];
    }
    resultValueStr = resultBuffer.toString();
    resultValueStrLength = resultValueStr.length;
    endPos = firstLineLen + resultValueStrLength;
    if (strBuffer.substr(endPos, crlfLen) !== crlf) {
      return [null, collectedLength, null, true];
    }
    ret[key] = resultValueStr;
    collectedLength += endPos + crlfLen;
  }
  return [null, collectedLength, null, true];
};

boolKeys = {
  "hash_is_expanding": true,
  "slab_reassign_running": true
};

stringKeys = {
  "version": true
};

Client.prototype.handle_stats = function(strBuffer) {
  var header, idx, isBoolKey, isNumberKey, key, line, lines, ret, statsData, value, _i, _len, _ref;
  if (strBuffer.indexOf(endTag) === 0) {
    return [{}, 5];
  }
  idx = strBuffer.indexOf(fullEndTag);
  if (idx === -1) {
    return null;
  }
  statsData = strBuffer.substr(0, idx + crlfLen);
  ret = {};
  line = null;
  lines = statsData.split(crlf);
  for (_i = 0, _len = lines.length; _i < _len; _i++) {
    line = lines[_i];
    _ref = line.split(' '), header = _ref[0], key = _ref[1], value = _ref[2];
    if (header !== "STAT") {
      continue;
    }
    isBoolKey = boolKeys[key];
    isNumberKey = !stringKeys[key];
    if (isBoolKey || isNumberKey) {
      value = parseFloat(value);
      if (isBoolKey) {
        value = !(value === 0);
      }
    }
    ret[key] = value;
  }
  return [ret, idx + fullEndTagLen, null];
};

Client.prototype.handle_simple = function(strBuffer) {
  var crlfPos, line;
  crlfPos = strBuffer.indexOf(crlf);
  if (crlfPos === -1) {
    return null;
  }
  line = strBuffer.substr(0, crlfPos);
  return [line, crlfPos + crlfLen, null];
};

Client.prototype.handle_version = function(strBuffer) {
  var lineLen, value;
  lineLen = strBuffer.indexOf(crlf);
  if (lineLen === -1) {
    return null;
  }
  value = strBuffer.substring('VERSION '.length, lineLen);
  return [value, lineLen + crlfLen, null];
};

Client.prototype.handle_error = function(strBuffer) {
  var crlfPos, line;
  crlfPos = strBuffer.indexOf(crlf);
  if (crlfPos === -1) {
    return null;
  }
  line = strBuffer.substr(0, crlfPos);
  return [null, crlfPos + crlfLen, line];
};
